# 一、需求分析
之前实现的是单机版本，用户只能在本地生成代码文件。现在要将其升级为平台化系统，这意味着需要支持多用户、应用管理、在线部署等功能。
需要的具体功能包括：

* 用户基础功能
  * 创建应用
  * 编辑应用信息
  * 删除自己的应用
  * 查看应用详情
  * 分页查询自己的应用列表
  * 分页查看精选应用列表
* 用户高级功能
  * ⭐ 实时查看应用效果
  * ⭐ 应用部署
* 管理功能
  * 管理所有应用（删除、查询、修改）
  * 设置精选应用

 业务流程：
 用户在主页输入提示词后，系统会创建一个应用记录，然后跳转到对话页面与 AI 交互生成网站。
 生成完成后，用户可以预览效果，满意后进行部署，让网站真正对外提供服务。


# 二、基本功能 后端接口
* 【用户】创建应用（须填写 initPrompt）
* 【用户】根据 id 修改自己的应用（目前只支持修改应用名称）
* 【用户】根据 id 删除自己的应用
* 【用户】根据 id 查看应用详情
* 【用户】分页查询自己的应用列表（支持根据名称查询，每页最多 20 个）
* 【用户】分页查询精选的应用列表（支持根据名称查询，每页最多 20 个）
* 【管理员】根据 id 删除任意应用
* 【管理员】根据 id 更新任意应用（支持更新应用名称、应用封面、优先级）
* 【管理员】分页查询应用列表（支持根据除时间外的任何字段查询，每页数量不限）
* 【管理员】根据 id 查看应用详情


开发流程
1、构建dto（编写Request）
2、根据Requset写Centroller和Service
3、部分内容需要做VO，
  service：数据封装（getVO，封装对象数据为VO数据），数据查询（getQueryWapper，将VO变为mybatis的查询对象）
  contorller：给出/get/vo接口，/my/list/page/vo

  有优化 public List<AppVO> getAppVOList(List<App> appList) {


# 三、应用生成 后端接口
参考大厂成熟平台方案，我们将整个集成流程抽象为以下三个步骤：
1. **应用入库**：用户在主页输入提示词创建应用，后端完成基础数据持久化。
2. **场景跳转**：前端获取 **应用 ID (AppID)** 后，携带该 ID 跳转至对话生成页面。
3. **自动生成**：系统自动触发初始提示词与 AI 对话，实时生成网站代码。

由于应用的生成过程和 AI 对话是绑定的，我们可以提供一个名为 chatToGenCode 的应用生成接口，调用之前开发的 AI 代码生成门面完成任务，并且流式返回给前端。 
前端不需要区分用户是否是第一次和该应用对话，始终调用这个接口即可，需要怎么做都交给后端来判断。

为了确保生成文件与应用实体的准确关联，必须规范存储路径：
  - **原方案**：`codeType_雪花算法`（纯随机，无业务属性）
  - **新方案**：`codeGenType_appId`（业务强相关）

> 此处刻意不使用 `deployKey` 作为目录名称，旨在从架构层面**区分部署环境与生成过程**。`appId` 锁定的是应用资产本身，而 `deployKey` 关注的是发布链路。



# 四、应用部署 后端接口
选择了混合方案：使用 Spring Boot 接口实现 AI 生成的网页预览，使用 Nginx 提供网站部署服务

开发 ：部署接口接受 appId 作为请求参数，返回可访问的 URL 地址：${部署域名}/{deployKey}。

部署流程如下：
参数校验：比如是否存在 App、用户是否有权限部署该应用（仅本人可以部署）。
生成 deployKey：之前设计库表时已经提到了 deployKey 的生成逻辑（6 位大小写字母 + 数字），还要注意不能跟已有的 key 重复；此外，每个 app 只生成一次 deployKey，已有则不生成。
部署操作：本质是将 code_output 目录下的临时文件复制到 code_deploy 目录下，为了简化访问地址，直接将 deployKey 作为文件名。
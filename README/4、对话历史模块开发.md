# 4、对话历史模块开发

## 一、需求分析

例子：用户首先让 AI 生成一个博客网站，然后希望在此基础上添加评论功能，最后再优化一下页面样式。

1. **对话历史的持久化存储：**用户发送消息时，需要保存用户消息；AI 成功回复后，需要保存 AI 消息。即使 AI 回复失败，也要记录错误信息，确保对话的完整性。

2. **应用级别的数据隔离：**每个应用的对话历史都是独立的。删除应用时，需要关联删除该应用的所有对话历史，避免数据冗余。

3. **对话历史查询：**支持分页查看某个应用的对话历史，需要区分用户和 AI 消息。类似聊天软件的消息加载机制，每次加载最新 10 条消息，支持向前加载更多历史记录。（仅应用创建者和管理员可见）

   详细来说，进入应用页面时，前端根据应用 id 先加载一次对话历史消息，关联查询最新 10 条消息。如果存在历史对话，直接展示；如果没有历史记录，才自动发送初始化提示词。这样就解决了之前浏览别人的应用时意外触发对话的问题。

4. **管理对话历史：**管理员可以查看所有应用的对话历史，按照时间降序排序，便于内容监管。

## 二、方案设计
在对话历史查询场景中，传统基于页码或偏移量的分页方式存在明显缺陷：

- **数据一致性问题：**当用户持续接收新消息时，若使用 LIMIT offset, count 方式分页，在查询第二页前若新增了数据，会导致原本的第一页数据变为第二页，造成消息重复加载或遗漏。
- **性能瓶颈问题：**在处理大量对话数据时，随着 offset 值增大，数据库需要扫描并跳过大量前置记录，查询性能会线性下降，在高并发场景下极易成为系统瓶颈。

**为解决上述问题，我们采用游标分页方案：**

- ​    选择对话历史的创建时间 createTime 作为游标，每次请求从上一次请求的游标开始加载数据：
- ​    前端每次加载下一页时，携带上一页最后一条消息的 createTime 作为游标值，后端从 createTime 小于当前游标值的数据开始查询，确保查询结果不受新增数据影响。

```sql
SELECT * FROM chat_history 
WHERE appId = 123 AND createTime < '2026-02-17 10:30:00'
ORDER BY createTime DESC 
LIMIT 10;
```

## 三、对话历史 基础功能

**新增对话历史：**对话历史的保存需要在**用户发送消息**和**AI 回复完成**这两个时机进行。无论 AI 回复成功还是失败，都要留下完整的对话记录，确保用户能够了解完整的交互历史。在 `ChatHistoryServiceImpl` 中提供统一的保存接口

**关联删除：**当应用被删除时，需要同步清理对话历史数据，在 `ChatHistoryServiceImpl` 中提供根据 `appId` 删除的方法

**游标查询：**

- 在 `model.dto.chathistory` 包下新建包含游标字段的请求对象（ChatHistoryQueryRequest）
- 在 `service.impl.ChatHistoryServiceImpl` 包下开发查询包装类构造方法（getQueryWapper）
- 在 `service.impl.ChatHistoryServiceImpl` 包下编写游标查询方法（listAppChatHistoryByPage）
- 在 `controller.ChatHistoryController` 包下编写接口

**管理员查询分页接口：**直接拉取全部，无需分页，调用 chatHistoryService.page() 即可



对话历史采用游标查询

重写 ServiceImpl 的 IService 的方法

为什么只有query请求需要这个注解@EqualsAndHashCode(callSuper = false)

重写public boolean removeById(Serializable id) {时候return super.removeById(id);